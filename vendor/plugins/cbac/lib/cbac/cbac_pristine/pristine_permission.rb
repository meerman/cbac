require File.expand_path(File.join(File.dirname(__FILE__), 'pristine_role'))
require 'active_record'

module Cbac
  module CbacPristine
    class PristinePermission < ActiveRecord::Base
      set_table_name 'cbac_staged_permissions'

      belongs_to :pristine_role

      #convert this pristine line to a yml statement which can be used to create a yml fixtures file
      #executing this statement will result in one cbac_permission in the DB
      def to_yml_fixture(fixture_id = nil)
        raise ArgumentError, "Error: cannot convert line #{line_number.to_s} to yml because the role is not specified" if pristine_role.nil?
        raise ArgumentError, "Error: cannot convert line #{line_number.to_s} to yml because the privilege_set_name is not specified" if privilege_set_name.blank?

        fixture_id = line_number if fixture_id.nil?

        yml = "cbac_permission_00" << fixture_id.to_s << ":\n"
        yml << "  id: " << fixture_id.to_s << "\n"
        yml << "  context_role: "
        yml << pristine_role.name if pristine_role.role_type == PristineRole.ROLE_TYPES[:context]
        yml << "\n"
        yml << "  generic_role_id: " << pristine_role.role_id.to_s << "\n"
        yml << "  privilege_set_id: <%= Cbac::PrivilegeSetRecord.find(:first, :conditions => {:name => '" << privilege_set_name << "'}).id %>\n"
        yml << "  created_at: " << Time.now.strftime("%Y-%m-%d %H:%M:%S") << "\n"
        yml << "  updated_at: " << Time.now.strftime("%Y-%m-%d %H:%M:%S") << "\n"
        yml << "\n"
      end

      # checks if the current cbac permissions contain a permission which is exactly like this one
      def exists?
        if pristine_role.role_type == PristineRole.ROLE_TYPES[:context]
          Cbac::Permission.count(:joins => [:privilege_set], :conditions => {:cbac_privilege_set => {:name => privilege_set_name}, :context_role => pristine_role.name}) > 0
        else
          Cbac::Permission.count(:joins => [:generic_role, :privilege_set], :conditions => {:cbac_privilege_set => {:name => privilege_set_name}, :cbac_generic_roles => {:name => pristine_role.name}}) > 0
        end
      end

      # checks if the known_permissions table has an entry for this permission
      def known_permission_exists?
        Cbac::KnownPermission.count(:conditions => {:permission_type => pristine_role.known_permission_type, :permission_number => line_number}) > 0
      end

      # accept this permission and apply to the current cbac permission set
      def accept
        case operand
          when '+'
            handle_grant_permission
          when '-'
            handle_revoke_permission
          when 'x', '=>'
            raise NotImplementedError, "Error: using an x or => in a pristine file is not implemented yet"
          else
            raise ArgumentError, "Error: invalid operand #{operand} is used in the pristine file"
        end
        Cbac::CbacPristine::PristinePermission.delete(id) unless id.nil?
      end

      # reject this permission, but register it as a known permission. The user actually rejected this himself.
      def reject
        register_change
      end

      # add this permission to the cbac permission set, unless it already exists
      def handle_grant_permission
        return if exists?

        permission = Cbac::Permission.new
        permission.privilege_set = Cbac::PrivilegeSetRecord.first(:conditions => {:name => privilege_set_name})

        if pristine_role.role_type == PristineRole.ROLE_TYPES[:context]
          permission.context_role = pristine_role.name
        else
          generic_role = Cbac::GenericRole.first(:conditions => {:name => pristine_role.name})
          permission.generic_role = generic_role.nil? ? Cbac::GenericRole.create(:name => pristine_role.name, :remarks => "Autogenerated by Cbac loading / upgrade system") : generic_role
        end

        register_change if permission.save
        permission
      end

      # revoke this permission from the current permission set, raises an error if it doesn't exist yet
      def handle_revoke_permission
        raise ArgumentError, "Error: trying to revoke permission #{privilege_set_name} for #{pristine_role.name}, but this permission does not exist" unless exists?

        if pristine_role.role_type == PristineRole.ROLE_TYPES[:context]
          permission = Cbac::Permission.first(:joins => [:privilege_set], :conditions => {:cbac_privilege_set => {:name => privilege_set_name}, :context_role => pristine_role.name})
        else
          permission = Cbac::Permission.first(:joins => [:generic_role, :privilege_set], :conditions => {:cbac_privilege_set => {:name => privilege_set_name}, :cbac_generic_roles => {:name => pristine_role.name}})
        end

        register_change if permission.destroy
      end

      # register this permission as a known permission
      def register_change
        Cbac::KnownPermission.create(:permission_number => line_number, :permission_type => pristine_role.known_permission_type)
      end

      # add this permission to the staging area
      def stage
        save unless known_permission_exists? or exists?
      end

      # clear the staging area of all generic pristine permissions
      def self.delete_generic_permissions
        generic_staged_permissions = all(:joins => :pristine_role, :conditions => ["cbac_staged_roles.role_type = ?", PristineRole.ROLE_TYPES[:generic]])
        generic_staged_permissions.each do |permission|
          delete(permission.id)
        end
      end

      # clear the staging area of all non generic permissions
      def self.delete_non_generic_permissions
        staged_permissions = all(:joins => :pristine_role, :conditions => ["cbac_staged_roles.role_type != ?", PristineRole.ROLE_TYPES[:generic]])
        staged_permissions.each do |permission|
          delete(permission.id)
        end
      end
    end
  end
end